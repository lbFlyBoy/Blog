title: iOS 图片（一）

date: 2015-11-07 10:21:45

tags: iOS

---

### 一：常见的图片格式、概念

1.1 常见图片格式
    
png、jpeg(jpg)、gif、webP、pdf (矢量图)

    疑惑1：jpeg、jpg 啥关系？
    jpg 是 jpeg 的简写缩写，jpg 是后缀名、jpeg 既可以是后缀名，也可以代表图片文件的格式

1.2 以上常见图片有什么区别

1.2.1 概念

    位图：就是一个像素数组,数组中的每个像素就代表着图片中的一个点。我们在应用中经常用到的 
    JPEG 和 PNG 图片就是位图。组成单位(像素)，特点缩放和旋转容易失真，同时文件容量较大

    像素: 一个像素所能表达的不同颜色数取决于比特每像素(BPP),通俗讲例如 8bit 位、16 比特位
    分别会有 256 色、65536 色。

    矢量图：组成单位(数学向量也就是矢量，比如物理学中的速度、加速度有大小和方向),放大后图像
          不会失真，和分辨率无关(比如 iPhone 上的图片只需要一套，不需要区分 2x、3x,
          可以减小资源包体积)

    透明通道: 透明通道也称 Alpha 通道，代表数字图像中像素点的透明信息。白色的 Alpha 像素用以定义
    不透明的彩色像素，而黑色的 Alpha 定以透明像素，黑白之间的灰阶则是彩色图片中的半透明部分

    硬编码、软编码、硬解码、软解码: 硬效率（细节看备注）

1.2.2 位图间区别

> png、jpeg(jpg)、gif、webP 都为一种压缩了的位图图像

特点:

    jepg: 支持有损压缩、可以控制压缩比、图像质量换得存储空间(iPhone 支持 jpeg 的硬编码和硬解码)

    png:  只支持无损压缩,压缩比是有上限的,优势在于支持完整的透明通道

    gif:  通常情况下只支持 256 种颜色、透明通道只有 1 bit、文件压缩比不高,  优势支持多帧动画

    webP: 支持有损和无损压缩、支持完整的透明通道、也支持多帧动画，并且没有版权问题，是一种 
          非常理想的图片格式,例如微博、微信、QQ、淘宝、网易新闻等等，每个 App 里都有 WebP 的身影

1.2.3 项目资源图片优化

Ⅰ) [ png 图片压缩](https://tinypng.com/)

    png 图片压缩,不是所 png 是无损压缩吗？怎么还压缩这里注意无损压缩不是 png 图片不支持压缩，
    是图片压缩有度

Ⅱ) [使用 IconFont ](https://github.com/JohnWong/IconFont)
    
    优点：
        1、图标集中处理，避免重复资源，设计师只要说明 Color、Size 就可以了
        2、减少包大小，每个 IconFont 只是一小段文本，文件大小要比图片形式的 icon 小一个数量级
        3、节省内存，IconFont 与普通文本一样是使用矢量图的方式绘制的
    特点：
        针对一些简单的图

Ⅲ) 使用 pdf 格式图片
    
    pdf 为矢量图跟屏幕分辨率没有关系，放到 xcode Assets.xcassets 目录中，iOS 本质上并不支持矢量图, 
    但是在编译阶段会将矢量图转化成目标设备对应的尺寸图(例如设备为 iPhone6 会生成对应的 2x 图片),
     同时会利用 xcassets 的特性在 iOS8.3 以上设备下支持部分资源下载, 包瘦身的效果。

### 二：imageNamed、imageWithContentsOfFile、imageWithData 方法区别

2.1 imageNamed:
        
    加载过程大概就是先从系统缓存中查找是否有，如果有就会直接加载；如果缓存中没有会查找这个方法从指定的 
    filePath 中加载然后缓存并返回这个对象。

注意：
缓存数据存储在全局缓存中，不会随着 UIImag 的释放而释放。缓存由系统管理程序员无法操作
所以这个方法的优点就是当加载时会缓存图片，我们一般加载经常使用的图片会使用该方法。

2.2 imageWithContentsOfFile、imageWithData
    
    只加载图片，不会缓存图片数据，适合较大图片或者使用频次少的图片。

注意：
这里说的不会缓存图片是相对 imageNamed: 方法的，imageWithContentsOfFile、imageWithData 的缓存会随 UIImage 对象的释放而释放

2.3 解惑
    
I) UIImage 中的缓存是怎么来的
    
    当调用 imageNamed: 方法时，系统会到指定 filepath 找对应的图片资源文件,然后将文件名
    放到 UIImage 对象中返回，并没有发生图片资源的读取或者解码操作。当 UIImage 对象
    赋值给 UIImageView 对象，UIImageView 渲染到屏幕上后系统才会真正调用解码方法，
    同时会将解码结果放到全局的缓存队列中，这个缓存只有在 APP 收到内存警告或推到后台才会清除。

Ⅱ) imageWithContentsOfFile、imageWithData 同样会有缓存
    
    通过数据创建 UIImage 时，UIImage底层会调用 ImageIO 的 CGImageSourceCreateWithData() 方法，
    该方法可以指定是否要缓存解码后的数据，在64位机器上默认需要缓存（kCGImageSourceShouldCache）。
    之后再调用 CGImageSourceCreateImageAtIndex() 可以设置是否需要立即进行
    解码（kCGImageSourceShouldCacheImmediately），如果设置为不需要立刻解码，同样也是在图片渲染
    到屏幕上后系统才会真正调用解码方法，解码数据会缓存到 CGImage 内部与上面的方法不同，
    这种方式创建的缓存会随着 UIImage 的释放而被释放掉。

Ⅲ) 缓存解压缩数据目前有什么问题
    
    我们知道了图片渲染到屏幕上，解压缩是必须的,因为 png、jpeg 都是经过压缩的位图。解压缩过程默认发生在
    主线程，如果加载大量图片肯定会影响性能

### 三：重新绘制图片，生成新的解压缩后的位图

网络图片库通用做法：把图片用 CGContextDrawImage() 绘制到画布上，然后把画布数据取出当做数据

    大概涉及到的方法：
    CGImageSourceRef imageSource = CGImageSourceCreateIncremental(NULL)  //创建一个空的图片源
    CGImageSourceUpdateData(imageSource,data, false) // 新数据来更新图片源
    CGImageRef partialImageRef = CGImageSourceCreateImageAtIndex(imageSource,0,NULL) 
   	 // 创建图片来显示。
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 像素的每个颜色
    分量使用的 bit 数, 位图的每一行使用的字节数, 颜色空间, 位图的布局信息);
    CGContextDrawImage(context,{0,0,w,h},partialImageRef)
    partialImageRef = CGBitmapContextCreateImage(bmContext)
    [UIImage imageWithCGImage:partialImageRef scale:1 orientation:orientation];


备注: 

[事务](http://www.jianshu.com/p/f8af20a5241c)

[简单谈谈硬编码和软编码](http://blog.csdn.net/zhubosa/article/details/51282246)

[位图](https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-SW3)

[矢量图](https://baike.baidu.com/item/%E7%9F%A2%E9%87%8F%E5%9B%BE)

[http://blog.corneliamu.com/archives/95](http://blog.corneliamu.com/archives/95)